// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_List
#include <List.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED__List_ListNode
#include <_List/ListNode.h>
#endif
#ifndef INCLUDED_format_png_Chunk
#include <format/png/Chunk.h>
#endif
#ifndef INCLUDED_format_png_Color
#include <format/png/Color.h>
#endif
#ifndef INCLUDED_format_png_Tools
#include <format/png/Tools.h>
#endif
#ifndef INCLUDED_format_tools_Deflate
#include <format/tools/Deflate.h>
#endif
#ifndef INCLUDED_format_tools_Inflate
#include <format/tools/Inflate.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_BytesBuffer
#include <haxe/io/BytesBuffer.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_35_getHeader,"format.png.Tools","getHeader",0xf1b59214,"format.png.Tools.getHeader","format/png/Tools.hx",35,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_47_getPalette,"format.png.Tools","getPalette",0x96858014,"format.png.Tools.getPalette","format/png/Tools.hx",47,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_56_filter,"format.png.Tools","filter",0xb708d3c7,"format.png.Tools.filter","format/png/Tools.hx",56,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_69_reverseBytes,"format.png.Tools","reverseBytes",0x2d518d38,"format.png.Tools.reverseBytes","format/png/Tools.hx",69,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_652_buildGrey,"format.png.Tools","buildGrey",0x5d0708fe,"format.png.Tools.buildGrey","format/png/Tools.hx",652,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_671_buildRGB,"format.png.Tools","buildRGB",0x68ea624e,"format.png.Tools.buildRGB","format/png/Tools.hx",671,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_694_build32ARGB,"format.png.Tools","build32ARGB",0x02e864aa,"format.png.Tools.build32ARGB","format/png/Tools.hx",694,0x79d90221)
HX_LOCAL_STACK_FRAME(_hx_pos_7ba0aa4bcda37a20_718_build32BGRA,"format.png.Tools","build32BGRA",0x03894c12,"format.png.Tools.build32BGRA","format/png/Tools.hx",718,0x79d90221)
namespace format{
namespace png{

void Tools_obj::__construct() { }

Dynamic Tools_obj::__CreateEmpty() { return new Tools_obj; }

void *Tools_obj::_hx_vtable = 0;

Dynamic Tools_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Tools_obj > _hx_result = new Tools_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Tools_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7b659811;
}

 ::Dynamic Tools_obj::getHeader( ::List d){
            	HX_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_35_getHeader)
HXLINE(  36)		{
HXLINE(  36)			 ::_List::ListNode _g_head = d->h;
HXDLIN(  36)			while(hx::IsNotNull( _g_head )){
HXLINE(  36)				 ::format::png::Chunk val = _g_head->item;
HXDLIN(  36)				_g_head = _g_head->next;
HXDLIN(  36)				 ::format::png::Chunk c = val;
HXLINE(  37)				if ((_hx_getEnumValueIndex(c) == (int)1)) {
HXLINE(  38)					 ::Dynamic h = c->_hx_getObject(0);
HXDLIN(  38)					return h;
            				}
            			}
            		}
HXLINE(  41)		HX_STACK_DO_THROW(HX_("Header not found",42,2b,e7,44));
HXDLIN(  41)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tools_obj,getHeader,return )

 ::haxe::io::Bytes Tools_obj::getPalette( ::List d){
            	HX_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_47_getPalette)
HXLINE(  48)		{
HXLINE(  48)			 ::_List::ListNode _g_head = d->h;
HXDLIN(  48)			while(hx::IsNotNull( _g_head )){
HXLINE(  48)				 ::format::png::Chunk val = _g_head->item;
HXDLIN(  48)				_g_head = _g_head->next;
HXDLIN(  48)				 ::format::png::Chunk c = val;
HXLINE(  49)				if ((_hx_getEnumValueIndex(c) == (int)3)) {
HXLINE(  50)					 ::haxe::io::Bytes b = c->_hx_getObject(0).StaticCast<  ::haxe::io::Bytes >();
HXDLIN(  50)					return b;
            				}
            			}
            		}
HXLINE(  53)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tools_obj,getPalette,return )

int Tools_obj::filter( ::haxe::io::Bytes data,int x,int y,int stride,int prev,int p,hx::Null< int >  __o_numChannels){
int numChannels = __o_numChannels.Default(4);
            	HX_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_56_filter)
HXLINE(  57)		int b;
HXDLIN(  57)		if ((y == (int)0)) {
HXLINE(  57)			b = (int)0;
            		}
            		else {
HXLINE(  57)			::Array< unsigned char > data1 = data->b;
HXDLIN(  57)			b = data1->__get((p - stride));
            		}
HXLINE(  58)		int c;
HXDLIN(  58)		bool c1;
HXDLIN(  58)		if ((x != (int)0)) {
HXLINE(  58)			c1 = (y == (int)0);
            		}
            		else {
HXLINE(  58)			c1 = true;
            		}
HXDLIN(  58)		if (c1) {
HXLINE(  58)			c = (int)0;
            		}
            		else {
HXLINE(  58)			::Array< unsigned char > data2 = data->b;
HXDLIN(  58)			c = data2->__get(((p - stride) - numChannels));
            		}
HXLINE(  59)		int k = ((prev + b) - c);
HXLINE(  60)		int pa = (k - prev);
HXDLIN(  60)		if ((pa < (int)0)) {
HXLINE(  60)			pa = -(pa);
            		}
HXLINE(  61)		int pb = (k - b);
HXDLIN(  61)		if ((pb < (int)0)) {
HXLINE(  61)			pb = -(pb);
            		}
HXLINE(  62)		int pc = (k - c);
HXDLIN(  62)		if ((pc < (int)0)) {
HXLINE(  62)			pc = -(pc);
            		}
HXLINE(  63)		bool _hx_tmp;
HXDLIN(  63)		if ((pa <= pb)) {
HXLINE(  63)			_hx_tmp = (pa <= pc);
            		}
            		else {
HXLINE(  63)			_hx_tmp = false;
            		}
HXDLIN(  63)		if (_hx_tmp) {
HXLINE(  63)			return prev;
            		}
            		else {
HXLINE(  63)			if ((pb <= pc)) {
HXLINE(  63)				return b;
            			}
            			else {
HXLINE(  63)				return c;
            			}
            		}
HXDLIN(  63)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Tools_obj,filter,return )

void Tools_obj::reverseBytes( ::haxe::io::Bytes b){
            	HX_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_69_reverseBytes)
HXLINE(  89)		int p = (int)0;
HXLINE(  90)		{
HXLINE(  90)			int _g1 = (int)0;
HXDLIN(  90)			int _g = ((int)b->length >> (int)(int)2);
HXDLIN(  90)			while((_g1 < _g)){
HXLINE(  90)				_g1 = (_g1 + (int)1);
HXDLIN(  90)				int i = (_g1 - (int)1);
HXLINE(  91)				int b1 = b->b->__get(p);
HXLINE(  92)				::Array< unsigned char > b2 = b->b;
HXDLIN(  92)				int g = b2->__get((p + (int)1));
HXLINE(  93)				::Array< unsigned char > b3 = b->b;
HXDLIN(  93)				int r = b3->__get((p + (int)2));
HXLINE(  94)				::Array< unsigned char > b4 = b->b;
HXDLIN(  94)				int a = b4->__get((p + (int)3));
HXLINE(  95)				{
HXLINE(  95)					p = (p + (int)1);
HXDLIN(  95)					b->b[(p - (int)1)] = a;
            				}
HXLINE(  96)				{
HXLINE(  96)					p = (p + (int)1);
HXDLIN(  96)					b->b[(p - (int)1)] = r;
            				}
HXLINE(  97)				{
HXLINE(  97)					p = (p + (int)1);
HXDLIN(  97)					b->b[(p - (int)1)] = g;
            				}
HXLINE(  98)				{
HXLINE(  98)					p = (p + (int)1);
HXDLIN(  98)					b->b[(p - (int)1)] = b1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tools_obj,reverseBytes,(void))

 ::haxe::io::Bytes Tools_obj::extractGrey( ::List d){
	HX_JUST_GC_STACKFRAME
	 ::Dynamic h = ::format::png::Tools_obj::getHeader(d);
	 ::haxe::io::Bytes grey = ::haxe::io::Bytes_obj::alloc((( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) ) * ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) )));
	 ::haxe::io::Bytes data = null();
	 ::haxe::io::BytesBuffer fullData = null();
	{
		 ::_List::ListNode _g_head = d->h;
		while(hx::IsNotNull( _g_head )){
			 ::format::png::Chunk val = _g_head->item;
			_g_head = _g_head->next;
			 ::format::png::Chunk c = val;
			if ((_hx_getEnumValueIndex(c) == (int)2)) {
				 ::haxe::io::Bytes b = c->_hx_getObject(0).StaticCast<  ::haxe::io::Bytes >();
				if (hx::IsNotNull( fullData )) {
					::Array< unsigned char > b1 = fullData->b;
					::Array< unsigned char > b2 = b->b;
					{
						int _g1 = (int)0;
						int _g = b->length;
						while((_g1 < _g)){
							_g1 = (_g1 + (int)1);
							int i = (_g1 - (int)1);
							::Array< unsigned char > fullData1 = fullData->b;
							fullData1->push(b2->__get(i));
						}
					}
				}
				else {
					if (hx::IsNull( data )) {
						data = b;
					}
					else {
						fullData =  ::haxe::io::BytesBuffer_obj::__alloc( HX_CTX );
						{
							::Array< unsigned char > b11 = fullData->b;
							::Array< unsigned char > b21 = data->b;
							{
								int _g11 = (int)0;
								int _g2 = data->length;
								while((_g11 < _g2)){
									_g11 = (_g11 + (int)1);
									int i1 = (_g11 - (int)1);
									::Array< unsigned char > fullData2 = fullData->b;
									fullData2->push(b21->__get(i1));
								}
							}
						}
						{
							::Array< unsigned char > b12 = fullData->b;
							::Array< unsigned char > b22 = b->b;
							{
								int _g12 = (int)0;
								int _g3 = b->length;
								while((_g12 < _g3)){
									_g12 = (_g12 + (int)1);
									int i2 = (_g12 - (int)1);
									::Array< unsigned char > fullData3 = fullData->b;
									fullData3->push(b22->__get(i2));
								}
							}
						}
						data = null();
					}
				}
			}
		}
	}
	if (hx::IsNotNull( fullData )) {
		data = fullData->getBytes();
	}
	if (hx::IsNull( data )) {
		HX_STACK_DO_THROW(HX_("Data not found",1f,f6,a3,e4));
	}
	data = ::format::tools::Inflate_obj::run(data);
	int r = (int)0;
	int w = (int)0;
	{
		 ::format::png::Color _g4 = h->__Field(HX_("color",63,71,5c,4a),hx::paccDynamic);
		if ((_hx_getEnumValueIndex(_g4) == (int)0)) {
			bool alpha = _g4->_hx_getBool(0);
			{
				if ((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) != (int)8)) {
					HX_STACK_DO_THROW(HX_("Unsupported color mode",eb,dc,a9,2c));
				}
				int width = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
				int stride;
				if (alpha) {
					stride = (int)2;
				}
				else {
					stride = (int)1;
				}
				int stride1 = ((stride * width) + (int)1);
				int data1 = data->length;
				if ((data1 < (( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) ) * stride1))) {
					HX_STACK_DO_THROW(HX_("Not enough data",ed,1b,e9,b2));
				}
				int rinc;
				if (alpha) {
					rinc = (int)2;
				}
				else {
					rinc = (int)1;
				}
				{
					int _g13 = (int)0;
					int _g5 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
					while((_g13 < _g5)){
						_g13 = (_g13 + (int)1);
						int y = (_g13 - (int)1);
						r = (r + (int)1);
						int f = data->b->__get((r - (int)1));
						switch((int)(f)){
							case (int)0: {
								int _g31 = (int)0;
								int _g21 = width;
								while((_g31 < _g21)){
									_g31 = (_g31 + (int)1);
									int x = (_g31 - (int)1);
									int v = data->b->__get(r);
									r = (r + rinc);
									{
										w = (w + (int)1);
										grey->b[(w - (int)1)] = v;
									}
								}
							}
							break;
							case (int)1: {
								int cv = (int)0;
								{
									int _g32 = (int)0;
									int _g22 = width;
									while((_g32 < _g22)){
										_g32 = (_g32 + (int)1);
										int x1 = (_g32 - (int)1);
										cv = (cv + data->b->__get(r));
										r = (r + rinc);
										{
											w = (w + (int)1);
											grey->b[(w - (int)1)] = cv;
										}
									}
								}
							}
							break;
							case (int)2: {
								int stride2;
								if ((y == (int)0)) {
									stride2 = (int)0;
								}
								else {
									stride2 = width;
								}
								{
									int _g33 = (int)0;
									int _g23 = width;
									while((_g33 < _g23)){
										_g33 = (_g33 + (int)1);
										int x2 = (_g33 - (int)1);
										int data2 = data->b->__get(r);
										::Array< unsigned char > grey1 = grey->b;
										int v1 = (data2 + grey1->__get((w - stride2)));
										r = (r + rinc);
										{
											w = (w + (int)1);
											grey->b[(w - (int)1)] = v1;
										}
									}
								}
							}
							break;
							case (int)3: {
								int cv1 = (int)0;
								int stride3;
								if ((y == (int)0)) {
									stride3 = (int)0;
								}
								else {
									stride3 = width;
								}
								{
									int _g34 = (int)0;
									int _g24 = width;
									while((_g34 < _g24)){
										_g34 = (_g34 + (int)1);
										int x3 = (_g34 - (int)1);
										int data3 = data->b->__get(r);
										::Array< unsigned char > grey2 = grey->b;
										cv1 = ((int)(data3 + ((int)(cv1 + grey2->__get((w - stride3))) >> (int)(int)1)) & (int)(int)255);
										r = (r + rinc);
										{
											w = (w + (int)1);
											grey->b[(w - (int)1)] = cv1;
										}
									}
								}
							}
							break;
							case (int)4: {
								int stride4 = width;
								int cv2 = (int)0;
								{
									int _g35 = (int)0;
									int _g25 = width;
									while((_g35 < _g25)){
										_g35 = (_g35 + (int)1);
										int x4 = (_g35 - (int)1);
										int b3;
										if ((y == (int)0)) {
											b3 = (int)0;
										}
										else {
											::Array< unsigned char > grey3 = grey->b;
											b3 = grey3->__get((w - stride4));
										}
										int c1;
										bool c2;
										if ((x4 != (int)0)) {
											c2 = (y == (int)0);
										}
										else {
											c2 = true;
										}
										if (c2) {
											c1 = (int)0;
										}
										else {
											::Array< unsigned char > grey4 = grey->b;
											c1 = grey4->__get(((w - stride4) - (int)1));
										}
										int k = ((cv2 + b3) - c1);
										int pa = (k - cv2);
										if ((pa < (int)0)) {
											pa = -(pa);
										}
										int pb = (k - b3);
										if ((pb < (int)0)) {
											pb = -(pb);
										}
										int pc = (k - c1);
										if ((pc < (int)0)) {
											pc = -(pc);
										}
										int cv3;
										bool cv4;
										if ((pa <= pb)) {
											cv4 = (pa <= pc);
										}
										else {
											cv4 = false;
										}
										if (cv4) {
											cv3 = cv2;
										}
										else {
											if ((pb <= pc)) {
												cv3 = b3;
											}
											else {
												cv3 = c1;
											}
										}
										cv2 = ((int)(cv3 + data->b->__get(r)) & (int)(int)255);
										r = (r + rinc);
										{
											w = (w + (int)1);
											grey->b[(w - (int)1)] = cv2;
										}
									}
								}
							}
							break;
							default:{
								HX_STACK_DO_THROW((HX_("Invalid filter ",1f,17,bf,04) + f));
							}
						}
					}
				}
			}
		}
		else {
			HX_STACK_DO_THROW(HX_("Unsupported color mode",eb,dc,a9,2c));
		}
	}
	return grey;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tools_obj,extractGrey,return )

 ::haxe::io::Bytes Tools_obj::extract32( ::List d, ::haxe::io::Bytes bytes, ::Dynamic flipY){
	HX_JUST_GC_STACKFRAME
	 ::Dynamic h = ::format::png::Tools_obj::getHeader(d);
	 ::haxe::io::Bytes bgra;
	if (hx::IsNull( bytes )) {
		bgra = ::haxe::io::Bytes_obj::alloc(((( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) ) * ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) )) * (int)4));
	}
	else {
		bgra = bytes;
	}
	 ::haxe::io::Bytes data = null();
	 ::haxe::io::BytesBuffer fullData = null();
	{
		 ::_List::ListNode _g_head = d->h;
		while(hx::IsNotNull( _g_head )){
			 ::format::png::Chunk val = _g_head->item;
			_g_head = _g_head->next;
			 ::format::png::Chunk c = val;
			if ((_hx_getEnumValueIndex(c) == (int)2)) {
				 ::haxe::io::Bytes b = c->_hx_getObject(0).StaticCast<  ::haxe::io::Bytes >();
				if (hx::IsNotNull( fullData )) {
					::Array< unsigned char > b1 = fullData->b;
					::Array< unsigned char > b2 = b->b;
					{
						int _g1 = (int)0;
						int _g = b->length;
						while((_g1 < _g)){
							_g1 = (_g1 + (int)1);
							int i = (_g1 - (int)1);
							::Array< unsigned char > fullData1 = fullData->b;
							fullData1->push(b2->__get(i));
						}
					}
				}
				else {
					if (hx::IsNull( data )) {
						data = b;
					}
					else {
						fullData =  ::haxe::io::BytesBuffer_obj::__alloc( HX_CTX );
						{
							::Array< unsigned char > b11 = fullData->b;
							::Array< unsigned char > b21 = data->b;
							{
								int _g11 = (int)0;
								int _g2 = data->length;
								while((_g11 < _g2)){
									_g11 = (_g11 + (int)1);
									int i1 = (_g11 - (int)1);
									::Array< unsigned char > fullData2 = fullData->b;
									fullData2->push(b21->__get(i1));
								}
							}
						}
						{
							::Array< unsigned char > b12 = fullData->b;
							::Array< unsigned char > b22 = b->b;
							{
								int _g12 = (int)0;
								int _g3 = b->length;
								while((_g12 < _g3)){
									_g12 = (_g12 + (int)1);
									int i2 = (_g12 - (int)1);
									::Array< unsigned char > fullData3 = fullData->b;
									fullData3->push(b22->__get(i2));
								}
							}
						}
						data = null();
					}
				}
			}
		}
	}
	if (hx::IsNotNull( fullData )) {
		data = fullData->getBytes();
	}
	if (hx::IsNull( data )) {
		HX_STACK_DO_THROW(HX_("Data not found",1f,f6,a3,e4));
	}
	data = ::format::tools::Inflate_obj::run(data);
	int r = (int)0;
	int w = (int)0;
	int lineDelta = (int)0;
	if (flipY) {
		lineDelta = (-(( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) )) * (int)8);
		int w1 = (( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) ) - (int)1);
		w = (w1 * (( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) ) * (int)4));
	}
	int flipY1;
	if (flipY) {
		flipY1 = (int)-1;
	}
	else {
		flipY1 = (int)1;
	}
	{
		 ::format::png::Color _g4 = h->__Field(HX_("color",63,71,5c,4a),hx::paccDynamic);
		switch((int)(_hx_getEnumValueIndex(_g4))){
			case (int)0: {
				bool alpha = _g4->_hx_getBool(0);
				{
					if ((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) != (int)8)) {
						HX_STACK_DO_THROW(HX_("Unsupported color mode",eb,dc,a9,2c));
					}
					int width = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
					int stride;
					if (alpha) {
						stride = (int)2;
					}
					else {
						stride = (int)1;
					}
					int stride1 = ((stride * width) + (int)1);
					int data1 = data->length;
					if ((data1 < (( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) ) * stride1))) {
						HX_STACK_DO_THROW(HX_("Not enough data",ed,1b,e9,b2));
					}
					int alphvaIdx = (int)-1;
					if (!(alpha)) {
						 ::_List::ListNode _g_head1 = d->h;
						while(hx::IsNotNull( _g_head1 )){
							 ::format::png::Chunk val1 = _g_head1->item;
							_g_head1 = _g_head1->next;
							 ::format::png::Chunk t = val1;
							if ((_hx_getEnumValueIndex(t) == (int)4)) {
								if ((t->_hx_getString(0) == HX_("tRNS",23,3d,eb,4c))) {
									 ::haxe::io::Bytes data2 = t->_hx_getObject(1).StaticCast<  ::haxe::io::Bytes >();
									if ((data2->length >= (int)2)) {
										alphvaIdx = data2->b->__get((int)1);
									}
									goto _hx_goto_21;
								}
							}
						}
						_hx_goto_21:;
					}
					{
						int _g13 = (int)0;
						int _g5 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
						while((_g13 < _g5)){
							_g13 = (_g13 + (int)1);
							int y = (_g13 - (int)1);
							r = (r + (int)1);
							int f = data->b->__get((r - (int)1));
							switch((int)(f)){
								case (int)0: {
									if (alpha) {
										int _g31 = (int)0;
										int _g21 = width;
										while((_g31 < _g21)){
											_g31 = (_g31 + (int)1);
											int x = (_g31 - (int)1);
											r = (r + (int)1);
											int v = data->b->__get((r - (int)1));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v;
											}
											{
												w = (w + (int)1);
												r = (r + (int)1);
												bgra->b[(w - (int)1)] = data->b->__get((r - (int)1));
											}
										}
									}
									else {
										int _g32 = (int)0;
										int _g22 = width;
										while((_g32 < _g22)){
											_g32 = (_g32 + (int)1);
											int x1 = (_g32 - (int)1);
											r = (r + (int)1);
											int v1 = data->b->__get((r - (int)1));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v1;
											}
											{
												w = (w + (int)1);
												int _hx_tmp;
												if ((v1 == alphvaIdx)) {
													_hx_tmp = (int)0;
												}
												else {
													_hx_tmp = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp;
											}
										}
									}
								}
								break;
								case (int)1: {
									int cv = (int)0;
									int ca = (int)0;
									if (alpha) {
										int _g33 = (int)0;
										int _g23 = width;
										while((_g33 < _g23)){
											_g33 = (_g33 + (int)1);
											int x2 = (_g33 - (int)1);
											r = (r + (int)1);
											cv = (cv + data->b->__get((r - (int)1)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											r = (r + (int)1);
											ca = (ca + data->b->__get((r - (int)1)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca;
											}
										}
									}
									else {
										int _g34 = (int)0;
										int _g24 = width;
										while((_g34 < _g24)){
											_g34 = (_g34 + (int)1);
											int x3 = (_g34 - (int)1);
											r = (r + (int)1);
											cv = (cv + data->b->__get((r - (int)1)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv;
											}
											{
												w = (w + (int)1);
												int _hx_tmp1;
												if ((cv == alphvaIdx)) {
													_hx_tmp1 = (int)0;
												}
												else {
													_hx_tmp1 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp1;
											}
										}
									}
								}
								break;
								case (int)2: {
									int stride2;
									if ((y == (int)0)) {
										stride2 = (int)0;
									}
									else {
										stride2 = ((width * (int)4) * flipY1);
									}
									if (alpha) {
										int _g35 = (int)0;
										int _g25 = width;
										while((_g35 < _g25)){
											_g35 = (_g35 + (int)1);
											int x4 = (_g35 - (int)1);
											r = (r + (int)1);
											int v2 = data->b->__get((r - (int)1));
											::Array< unsigned char > bgra1 = bgra->b;
											int v3 = (v2 + bgra1->__get((w - stride2)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v3;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v3;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v3;
											}
											{
												w = (w + (int)1);
												r = (r + (int)1);
												int v4 = data->b->__get((r - (int)1));
												::Array< unsigned char > bgra2 = bgra->b;
												bgra->b[(w - (int)1)] = (v4 + bgra2->__get((w - stride2)));
											}
										}
									}
									else {
										int _g36 = (int)0;
										int _g26 = width;
										while((_g36 < _g26)){
											_g36 = (_g36 + (int)1);
											int x5 = (_g36 - (int)1);
											r = (r + (int)1);
											int v5 = data->b->__get((r - (int)1));
											::Array< unsigned char > bgra3 = bgra->b;
											int v6 = (v5 + bgra3->__get((w - stride2)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v6;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v6;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = v6;
											}
											{
												w = (w + (int)1);
												int _hx_tmp2;
												if ((v6 == alphvaIdx)) {
													_hx_tmp2 = (int)0;
												}
												else {
													_hx_tmp2 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp2;
											}
										}
									}
								}
								break;
								case (int)3: {
									int cv1 = (int)0;
									int ca1 = (int)0;
									int stride3;
									if ((y == (int)0)) {
										stride3 = (int)0;
									}
									else {
										stride3 = ((width * (int)4) * flipY1);
									}
									if (alpha) {
										int _g37 = (int)0;
										int _g27 = width;
										while((_g37 < _g27)){
											_g37 = (_g37 + (int)1);
											int x6 = (_g37 - (int)1);
											r = (r + (int)1);
											int cv2 = data->b->__get((r - (int)1));
											::Array< unsigned char > bgra4 = bgra->b;
											cv1 = ((int)(cv2 + ((int)(cv1 + bgra4->__get((w - stride3))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											r = (r + (int)1);
											int ca2 = data->b->__get((r - (int)1));
											::Array< unsigned char > bgra5 = bgra->b;
											ca1 = ((int)(ca2 + ((int)(ca1 + bgra5->__get((w - stride3))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca1;
											}
										}
									}
									else {
										int _g38 = (int)0;
										int _g28 = width;
										while((_g38 < _g28)){
											_g38 = (_g38 + (int)1);
											int x7 = (_g38 - (int)1);
											r = (r + (int)1);
											int cv3 = data->b->__get((r - (int)1));
											::Array< unsigned char > bgra6 = bgra->b;
											cv1 = ((int)(cv3 + ((int)(cv1 + bgra6->__get((w - stride3))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv1;
											}
											{
												w = (w + (int)1);
												int _hx_tmp3;
												if ((cv1 == alphvaIdx)) {
													_hx_tmp3 = (int)0;
												}
												else {
													_hx_tmp3 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp3;
											}
										}
									}
								}
								break;
								case (int)4: {
									int stride4 = ((width * (int)4) * flipY1);
									int cv4 = (int)0;
									int ca3 = (int)0;
									if (alpha) {
										int _g39 = (int)0;
										int _g29 = width;
										while((_g39 < _g29)){
											_g39 = (_g39 + (int)1);
											int x8 = (_g39 - (int)1);
											int b3;
											if ((y == (int)0)) {
												b3 = (int)0;
											}
											else {
												::Array< unsigned char > bgra7 = bgra->b;
												b3 = bgra7->__get((w - stride4));
											}
											int c1;
											bool c2;
											if ((x8 != (int)0)) {
												c2 = (y == (int)0);
											}
											else {
												c2 = true;
											}
											if (c2) {
												c1 = (int)0;
											}
											else {
												::Array< unsigned char > bgra8 = bgra->b;
												c1 = bgra8->__get(((w - stride4) - (int)4));
											}
											int k = ((cv4 + b3) - c1);
											int pa = (k - cv4);
											if ((pa < (int)0)) {
												pa = -(pa);
											}
											int pb = (k - b3);
											if ((pb < (int)0)) {
												pb = -(pb);
											}
											int pc = (k - c1);
											if ((pc < (int)0)) {
												pc = -(pc);
											}
											int cv5;
											bool cv6;
											if ((pa <= pb)) {
												cv6 = (pa <= pc);
											}
											else {
												cv6 = false;
											}
											if (cv6) {
												cv5 = cv4;
											}
											else {
												if ((pb <= pc)) {
													cv5 = b3;
												}
												else {
													cv5 = c1;
												}
											}
											r = (r + (int)1);
											cv4 = ((int)(cv5 + data->b->__get((r - (int)1))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											int b4;
											if ((y == (int)0)) {
												b4 = (int)0;
											}
											else {
												::Array< unsigned char > bgra9 = bgra->b;
												b4 = bgra9->__get((w - stride4));
											}
											int c3;
											bool c4;
											if ((x8 != (int)0)) {
												c4 = (y == (int)0);
											}
											else {
												c4 = true;
											}
											if (c4) {
												c3 = (int)0;
											}
											else {
												::Array< unsigned char > bgra10 = bgra->b;
												c3 = bgra10->__get(((w - stride4) - (int)4));
											}
											int k1 = ((ca3 + b4) - c3);
											int pa1 = (k1 - ca3);
											if ((pa1 < (int)0)) {
												pa1 = -(pa1);
											}
											int pb1 = (k1 - b4);
											if ((pb1 < (int)0)) {
												pb1 = -(pb1);
											}
											int pc1 = (k1 - c3);
											if ((pc1 < (int)0)) {
												pc1 = -(pc1);
											}
											int ca4;
											bool ca5;
											if ((pa1 <= pb1)) {
												ca5 = (pa1 <= pc1);
											}
											else {
												ca5 = false;
											}
											if (ca5) {
												ca4 = ca3;
											}
											else {
												if ((pb1 <= pc1)) {
													ca4 = b4;
												}
												else {
													ca4 = c3;
												}
											}
											r = (r + (int)1);
											ca3 = ((int)(ca4 + data->b->__get((r - (int)1))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca3;
											}
										}
									}
									else {
										int _g310 = (int)0;
										int _g210 = width;
										while((_g310 < _g210)){
											_g310 = (_g310 + (int)1);
											int x9 = (_g310 - (int)1);
											int b5;
											if ((y == (int)0)) {
												b5 = (int)0;
											}
											else {
												::Array< unsigned char > bgra11 = bgra->b;
												b5 = bgra11->__get((w - stride4));
											}
											int c5;
											bool c6;
											if ((x9 != (int)0)) {
												c6 = (y == (int)0);
											}
											else {
												c6 = true;
											}
											if (c6) {
												c5 = (int)0;
											}
											else {
												::Array< unsigned char > bgra12 = bgra->b;
												c5 = bgra12->__get(((w - stride4) - (int)4));
											}
											int k2 = ((cv4 + b5) - c5);
											int pa2 = (k2 - cv4);
											if ((pa2 < (int)0)) {
												pa2 = -(pa2);
											}
											int pb2 = (k2 - b5);
											if ((pb2 < (int)0)) {
												pb2 = -(pb2);
											}
											int pc2 = (k2 - c5);
											if ((pc2 < (int)0)) {
												pc2 = -(pc2);
											}
											int cv7;
											bool cv8;
											if ((pa2 <= pb2)) {
												cv8 = (pa2 <= pc2);
											}
											else {
												cv8 = false;
											}
											if (cv8) {
												cv7 = cv4;
											}
											else {
												if ((pb2 <= pc2)) {
													cv7 = b5;
												}
												else {
													cv7 = c5;
												}
											}
											r = (r + (int)1);
											cv4 = ((int)(cv7 + data->b->__get((r - (int)1))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cv4;
											}
											{
												w = (w + (int)1);
												int _hx_tmp4;
												if ((cv4 == alphvaIdx)) {
													_hx_tmp4 = (int)0;
												}
												else {
													_hx_tmp4 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp4;
											}
										}
									}
								}
								break;
								default:{
									HX_STACK_DO_THROW((HX_("Invalid filter ",1f,17,bf,04) + f));
								}
							}
							w = (w + lineDelta);
						}
					}
				}
			}
			break;
			case (int)1: {
				bool alpha1 = _g4->_hx_getBool(0);
				{
					if ((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) != (int)8)) {
						HX_STACK_DO_THROW(HX_("Unsupported color mode",eb,dc,a9,2c));
					}
					int width1 = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
					int stride5;
					if (alpha1) {
						stride5 = (int)4;
					}
					else {
						stride5 = (int)3;
					}
					int stride6 = ((stride5 * width1) + (int)1);
					int data3 = data->length;
					if ((data3 < (( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) ) * stride6))) {
						HX_STACK_DO_THROW(HX_("Not enough data",ed,1b,e9,b2));
					}
					int alphaRed = (int)-1;
					int alphaGreen = (int)-1;
					int alphaBlue = (int)-1;
					if (!(alpha1)) {
						 ::_List::ListNode _g_head2 = d->h;
						while(hx::IsNotNull( _g_head2 )){
							 ::format::png::Chunk val2 = _g_head2->item;
							_g_head2 = _g_head2->next;
							 ::format::png::Chunk t1 = val2;
							if ((_hx_getEnumValueIndex(t1) == (int)4)) {
								if ((t1->_hx_getString(0) == HX_("tRNS",23,3d,eb,4c))) {
									 ::haxe::io::Bytes data4 = t1->_hx_getObject(1).StaticCast<  ::haxe::io::Bytes >();
									if ((data4->length >= (int)6)) {
										alphaRed = data4->b->__get((int)1);
										alphaGreen = data4->b->__get((int)3);
										alphaBlue = data4->b->__get((int)5);
									}
									goto _hx_goto_33;
								}
							}
						}
						_hx_goto_33:;
					}
					int cr = (int)0;
					int cg = (int)0;
					int cb = (int)0;
					int ca6 = (int)0;
					{
						int _g14 = (int)0;
						int _g6 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
						while((_g14 < _g6)){
							_g14 = (_g14 + (int)1);
							int y1 = (_g14 - (int)1);
							r = (r + (int)1);
							int f1 = data->b->__get((r - (int)1));
							switch((int)(f1)){
								case (int)0: {
									if (alpha1) {
										int _g311 = (int)0;
										int _g211 = width1;
										while((_g311 < _g211)){
											_g311 = (_g311 + (int)1);
											int x10 = (_g311 - (int)1);
											{
												w = (w + (int)1);
												::Array< unsigned char > data5 = data->b;
												bgra->b[(w - (int)1)] = data5->__get((r + (int)2));
											}
											{
												w = (w + (int)1);
												::Array< unsigned char > data6 = data->b;
												bgra->b[(w - (int)1)] = data6->__get((r + (int)1));
											}
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = data->b->__get(r);
											}
											{
												w = (w + (int)1);
												::Array< unsigned char > data7 = data->b;
												bgra->b[(w - (int)1)] = data7->__get((r + (int)3));
											}
											r = (r + (int)4);
										}
									}
									else {
										int _g312 = (int)0;
										int _g212 = width1;
										while((_g312 < _g212)){
											_g312 = (_g312 + (int)1);
											int x11 = (_g312 - (int)1);
											{
												w = (w + (int)1);
												::Array< unsigned char > data8 = data->b;
												cb = data8->__get((r + (int)2));
												bgra->b[(w - (int)1)] = cb;
											}
											{
												w = (w + (int)1);
												::Array< unsigned char > data9 = data->b;
												cg = data9->__get((r + (int)1));
												bgra->b[(w - (int)1)] = cg;
											}
											{
												w = (w + (int)1);
												cr = data->b->__get(r);
												bgra->b[(w - (int)1)] = cr;
											}
											{
												w = (w + (int)1);
												int _hx_tmp5;
												bool _hx_tmp6;
												bool _hx_tmp7;
												if ((cr == alphaRed)) {
													_hx_tmp7 = (cg == alphaGreen);
												}
												else {
													_hx_tmp7 = false;
												}
												if (_hx_tmp7) {
													_hx_tmp6 = (cb == alphaBlue);
												}
												else {
													_hx_tmp6 = false;
												}
												if (_hx_tmp6) {
													_hx_tmp5 = (int)0;
												}
												else {
													_hx_tmp5 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp5;
											}
											r = (r + (int)3);
										}
									}
								}
								break;
								case (int)1: {
									ca6 = (int)0;
									cb = ca6;
									cg = cb;
									cr = cg;
									if (alpha1) {
										int _g313 = (int)0;
										int _g213 = width1;
										while((_g313 < _g213)){
											_g313 = (_g313 + (int)1);
											int x12 = (_g313 - (int)1);
											::Array< unsigned char > data10 = data->b;
											cb = (cb + data10->__get((r + (int)2)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											::Array< unsigned char > data11 = data->b;
											cg = (cg + data11->__get((r + (int)1)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											cr = (cr + data->b->__get(r));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											::Array< unsigned char > data12 = data->b;
											ca6 = (ca6 + data12->__get((r + (int)3)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca6;
											}
											r = (r + (int)4);
										}
									}
									else {
										int _g314 = (int)0;
										int _g214 = width1;
										while((_g314 < _g214)){
											_g314 = (_g314 + (int)1);
											int x13 = (_g314 - (int)1);
											::Array< unsigned char > data13 = data->b;
											cb = (cb + data13->__get((r + (int)2)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											::Array< unsigned char > data14 = data->b;
											cg = (cg + data14->__get((r + (int)1)));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											cr = (cr + data->b->__get(r));
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											{
												w = (w + (int)1);
												int _hx_tmp8;
												bool _hx_tmp9;
												bool _hx_tmp10;
												if ((cr == alphaRed)) {
													_hx_tmp10 = (cg == alphaGreen);
												}
												else {
													_hx_tmp10 = false;
												}
												if (_hx_tmp10) {
													_hx_tmp9 = (cb == alphaBlue);
												}
												else {
													_hx_tmp9 = false;
												}
												if (_hx_tmp9) {
													_hx_tmp8 = (int)0;
												}
												else {
													_hx_tmp8 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp8;
											}
											r = (r + (int)3);
										}
									}
								}
								break;
								case (int)2: {
									int stride7;
									if ((y1 == (int)0)) {
										stride7 = (int)0;
									}
									else {
										stride7 = ((width1 * (int)4) * flipY1);
									}
									if (alpha1) {
										int _g315 = (int)0;
										int _g215 = width1;
										while((_g315 < _g215)){
											_g315 = (_g315 + (int)1);
											int x14 = (_g315 - (int)1);
											{
												::Array< unsigned char > data15 = data->b;
												int data16 = data15->__get((r + (int)2));
												::Array< unsigned char > bgra13 = bgra->b;
												bgra->b[w] = (data16 + bgra13->__get((w - stride7)));
											}
											w = (w + (int)1);
											{
												::Array< unsigned char > data17 = data->b;
												int data18 = data17->__get((r + (int)1));
												::Array< unsigned char > bgra14 = bgra->b;
												bgra->b[w] = (data18 + bgra14->__get((w - stride7)));
											}
											w = (w + (int)1);
											{
												int data19 = data->b->__get(r);
												::Array< unsigned char > bgra15 = bgra->b;
												bgra->b[w] = (data19 + bgra15->__get((w - stride7)));
											}
											w = (w + (int)1);
											{
												::Array< unsigned char > data20 = data->b;
												int data21 = data20->__get((r + (int)3));
												::Array< unsigned char > bgra16 = bgra->b;
												bgra->b[w] = (data21 + bgra16->__get((w - stride7)));
											}
											w = (w + (int)1);
											r = (r + (int)4);
										}
									}
									else {
										int _g316 = (int)0;
										int _g216 = width1;
										while((_g316 < _g216)){
											_g316 = (_g316 + (int)1);
											int x15 = (_g316 - (int)1);
											{
												::Array< unsigned char > data22 = data->b;
												int data23 = data22->__get((r + (int)2));
												::Array< unsigned char > bgra17 = bgra->b;
												cb = (data23 + bgra17->__get((w - stride7)));
												bgra->b[w] = cb;
											}
											w = (w + (int)1);
											{
												::Array< unsigned char > data24 = data->b;
												int data25 = data24->__get((r + (int)1));
												::Array< unsigned char > bgra18 = bgra->b;
												cg = (data25 + bgra18->__get((w - stride7)));
												bgra->b[w] = cg;
											}
											w = (w + (int)1);
											{
												int data26 = data->b->__get(r);
												::Array< unsigned char > bgra19 = bgra->b;
												cr = (data26 + bgra19->__get((w - stride7)));
												bgra->b[w] = cr;
											}
											w = (w + (int)1);
											{
												w = (w + (int)1);
												int _hx_tmp11;
												bool _hx_tmp12;
												bool _hx_tmp13;
												if ((cr == alphaRed)) {
													_hx_tmp13 = (cg == alphaGreen);
												}
												else {
													_hx_tmp13 = false;
												}
												if (_hx_tmp13) {
													_hx_tmp12 = (cb == alphaBlue);
												}
												else {
													_hx_tmp12 = false;
												}
												if (_hx_tmp12) {
													_hx_tmp11 = (int)0;
												}
												else {
													_hx_tmp11 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp11;
											}
											r = (r + (int)3);
										}
									}
								}
								break;
								case (int)3: {
									ca6 = (int)0;
									cb = ca6;
									cg = cb;
									cr = cg;
									int stride8;
									if ((y1 == (int)0)) {
										stride8 = (int)0;
									}
									else {
										stride8 = ((width1 * (int)4) * flipY1);
									}
									if (alpha1) {
										int _g317 = (int)0;
										int _g217 = width1;
										while((_g317 < _g217)){
											_g317 = (_g317 + (int)1);
											int x16 = (_g317 - (int)1);
											::Array< unsigned char > data27 = data->b;
											int data28 = data27->__get((r + (int)2));
											::Array< unsigned char > bgra20 = bgra->b;
											cb = ((int)(data28 + ((int)(cb + bgra20->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											::Array< unsigned char > data29 = data->b;
											int data30 = data29->__get((r + (int)1));
											::Array< unsigned char > bgra21 = bgra->b;
											cg = ((int)(data30 + ((int)(cg + bgra21->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											int data31 = data->b->__get(r);
											::Array< unsigned char > bgra22 = bgra->b;
											cr = ((int)(data31 + ((int)(cr + bgra22->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											::Array< unsigned char > data32 = data->b;
											int data33 = data32->__get((r + (int)3));
											::Array< unsigned char > bgra23 = bgra->b;
											ca6 = ((int)(data33 + ((int)(ca6 + bgra23->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca6;
											}
											r = (r + (int)4);
										}
									}
									else {
										int _g318 = (int)0;
										int _g218 = width1;
										while((_g318 < _g218)){
											_g318 = (_g318 + (int)1);
											int x17 = (_g318 - (int)1);
											::Array< unsigned char > data34 = data->b;
											int data35 = data34->__get((r + (int)2));
											::Array< unsigned char > bgra24 = bgra->b;
											cb = ((int)(data35 + ((int)(cb + bgra24->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											::Array< unsigned char > data36 = data->b;
											int data37 = data36->__get((r + (int)1));
											::Array< unsigned char > bgra25 = bgra->b;
											cg = ((int)(data37 + ((int)(cg + bgra25->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											int data38 = data->b->__get(r);
											::Array< unsigned char > bgra26 = bgra->b;
											cr = ((int)(data38 + ((int)(cr + bgra26->__get((w - stride8))) >> (int)(int)1)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											{
												w = (w + (int)1);
												int _hx_tmp14;
												bool _hx_tmp15;
												bool _hx_tmp16;
												if ((cr == alphaRed)) {
													_hx_tmp16 = (cg == alphaGreen);
												}
												else {
													_hx_tmp16 = false;
												}
												if (_hx_tmp16) {
													_hx_tmp15 = (cb == alphaBlue);
												}
												else {
													_hx_tmp15 = false;
												}
												if (_hx_tmp15) {
													_hx_tmp14 = (int)0;
												}
												else {
													_hx_tmp14 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp14;
											}
											r = (r + (int)3);
										}
									}
								}
								break;
								case (int)4: {
									int stride9 = ((width1 * (int)4) * flipY1);
									ca6 = (int)0;
									cb = ca6;
									cg = cb;
									cr = cg;
									if (alpha1) {
										int _g319 = (int)0;
										int _g219 = width1;
										while((_g319 < _g219)){
											_g319 = (_g319 + (int)1);
											int x18 = (_g319 - (int)1);
											int b6;
											if ((y1 == (int)0)) {
												b6 = (int)0;
											}
											else {
												::Array< unsigned char > bgra27 = bgra->b;
												b6 = bgra27->__get((w - stride9));
											}
											int c7;
											bool c8;
											if ((x18 != (int)0)) {
												c8 = (y1 == (int)0);
											}
											else {
												c8 = true;
											}
											if (c8) {
												c7 = (int)0;
											}
											else {
												::Array< unsigned char > bgra28 = bgra->b;
												c7 = bgra28->__get(((w - stride9) - (int)4));
											}
											int k3 = ((cb + b6) - c7);
											int pa3 = (k3 - cb);
											if ((pa3 < (int)0)) {
												pa3 = -(pa3);
											}
											int pb3 = (k3 - b6);
											if ((pb3 < (int)0)) {
												pb3 = -(pb3);
											}
											int pc3 = (k3 - c7);
											if ((pc3 < (int)0)) {
												pc3 = -(pc3);
											}
											int cb1;
											bool cb2;
											if ((pa3 <= pb3)) {
												cb2 = (pa3 <= pc3);
											}
											else {
												cb2 = false;
											}
											if (cb2) {
												cb1 = cb;
											}
											else {
												if ((pb3 <= pc3)) {
													cb1 = b6;
												}
												else {
													cb1 = c7;
												}
											}
											::Array< unsigned char > data39 = data->b;
											cb = ((int)(cb1 + data39->__get((r + (int)2))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											int b7;
											if ((y1 == (int)0)) {
												b7 = (int)0;
											}
											else {
												::Array< unsigned char > bgra29 = bgra->b;
												b7 = bgra29->__get((w - stride9));
											}
											int c9;
											bool c10;
											if ((x18 != (int)0)) {
												c10 = (y1 == (int)0);
											}
											else {
												c10 = true;
											}
											if (c10) {
												c9 = (int)0;
											}
											else {
												::Array< unsigned char > bgra30 = bgra->b;
												c9 = bgra30->__get(((w - stride9) - (int)4));
											}
											int k4 = ((cg + b7) - c9);
											int pa4 = (k4 - cg);
											if ((pa4 < (int)0)) {
												pa4 = -(pa4);
											}
											int pb4 = (k4 - b7);
											if ((pb4 < (int)0)) {
												pb4 = -(pb4);
											}
											int pc4 = (k4 - c9);
											if ((pc4 < (int)0)) {
												pc4 = -(pc4);
											}
											int cg1;
											bool cg2;
											if ((pa4 <= pb4)) {
												cg2 = (pa4 <= pc4);
											}
											else {
												cg2 = false;
											}
											if (cg2) {
												cg1 = cg;
											}
											else {
												if ((pb4 <= pc4)) {
													cg1 = b7;
												}
												else {
													cg1 = c9;
												}
											}
											::Array< unsigned char > data40 = data->b;
											cg = ((int)(cg1 + data40->__get((r + (int)1))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											int b8;
											if ((y1 == (int)0)) {
												b8 = (int)0;
											}
											else {
												::Array< unsigned char > bgra31 = bgra->b;
												b8 = bgra31->__get((w - stride9));
											}
											int c11;
											bool c12;
											if ((x18 != (int)0)) {
												c12 = (y1 == (int)0);
											}
											else {
												c12 = true;
											}
											if (c12) {
												c11 = (int)0;
											}
											else {
												::Array< unsigned char > bgra32 = bgra->b;
												c11 = bgra32->__get(((w - stride9) - (int)4));
											}
											int k5 = ((cr + b8) - c11);
											int pa5 = (k5 - cr);
											if ((pa5 < (int)0)) {
												pa5 = -(pa5);
											}
											int pb5 = (k5 - b8);
											if ((pb5 < (int)0)) {
												pb5 = -(pb5);
											}
											int pc5 = (k5 - c11);
											if ((pc5 < (int)0)) {
												pc5 = -(pc5);
											}
											int cr1;
											bool cr2;
											if ((pa5 <= pb5)) {
												cr2 = (pa5 <= pc5);
											}
											else {
												cr2 = false;
											}
											if (cr2) {
												cr1 = cr;
											}
											else {
												if ((pb5 <= pc5)) {
													cr1 = b8;
												}
												else {
													cr1 = c11;
												}
											}
											cr = ((int)(cr1 + data->b->__get(r)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											int b9;
											if ((y1 == (int)0)) {
												b9 = (int)0;
											}
											else {
												::Array< unsigned char > bgra33 = bgra->b;
												b9 = bgra33->__get((w - stride9));
											}
											int c13;
											bool c14;
											if ((x18 != (int)0)) {
												c14 = (y1 == (int)0);
											}
											else {
												c14 = true;
											}
											if (c14) {
												c13 = (int)0;
											}
											else {
												::Array< unsigned char > bgra34 = bgra->b;
												c13 = bgra34->__get(((w - stride9) - (int)4));
											}
											int k6 = ((ca6 + b9) - c13);
											int pa6 = (k6 - ca6);
											if ((pa6 < (int)0)) {
												pa6 = -(pa6);
											}
											int pb6 = (k6 - b9);
											if ((pb6 < (int)0)) {
												pb6 = -(pb6);
											}
											int pc6 = (k6 - c13);
											if ((pc6 < (int)0)) {
												pc6 = -(pc6);
											}
											int ca7;
											bool ca8;
											if ((pa6 <= pb6)) {
												ca8 = (pa6 <= pc6);
											}
											else {
												ca8 = false;
											}
											if (ca8) {
												ca7 = ca6;
											}
											else {
												if ((pb6 <= pc6)) {
													ca7 = b9;
												}
												else {
													ca7 = c13;
												}
											}
											::Array< unsigned char > data41 = data->b;
											ca6 = ((int)(ca7 + data41->__get((r + (int)3))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = ca6;
											}
											r = (r + (int)4);
										}
									}
									else {
										int _g320 = (int)0;
										int _g220 = width1;
										while((_g320 < _g220)){
											_g320 = (_g320 + (int)1);
											int x19 = (_g320 - (int)1);
											int b10;
											if ((y1 == (int)0)) {
												b10 = (int)0;
											}
											else {
												::Array< unsigned char > bgra35 = bgra->b;
												b10 = bgra35->__get((w - stride9));
											}
											int c15;
											bool c16;
											if ((x19 != (int)0)) {
												c16 = (y1 == (int)0);
											}
											else {
												c16 = true;
											}
											if (c16) {
												c15 = (int)0;
											}
											else {
												::Array< unsigned char > bgra36 = bgra->b;
												c15 = bgra36->__get(((w - stride9) - (int)4));
											}
											int k7 = ((cb + b10) - c15);
											int pa7 = (k7 - cb);
											if ((pa7 < (int)0)) {
												pa7 = -(pa7);
											}
											int pb7 = (k7 - b10);
											if ((pb7 < (int)0)) {
												pb7 = -(pb7);
											}
											int pc7 = (k7 - c15);
											if ((pc7 < (int)0)) {
												pc7 = -(pc7);
											}
											int cb3;
											bool cb4;
											if ((pa7 <= pb7)) {
												cb4 = (pa7 <= pc7);
											}
											else {
												cb4 = false;
											}
											if (cb4) {
												cb3 = cb;
											}
											else {
												if ((pb7 <= pc7)) {
													cb3 = b10;
												}
												else {
													cb3 = c15;
												}
											}
											::Array< unsigned char > data42 = data->b;
											cb = ((int)(cb3 + data42->__get((r + (int)2))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cb;
											}
											int b13;
											if ((y1 == (int)0)) {
												b13 = (int)0;
											}
											else {
												::Array< unsigned char > bgra37 = bgra->b;
												b13 = bgra37->__get((w - stride9));
											}
											int c17;
											bool c18;
											if ((x19 != (int)0)) {
												c18 = (y1 == (int)0);
											}
											else {
												c18 = true;
											}
											if (c18) {
												c17 = (int)0;
											}
											else {
												::Array< unsigned char > bgra38 = bgra->b;
												c17 = bgra38->__get(((w - stride9) - (int)4));
											}
											int k8 = ((cg + b13) - c17);
											int pa8 = (k8 - cg);
											if ((pa8 < (int)0)) {
												pa8 = -(pa8);
											}
											int pb8 = (k8 - b13);
											if ((pb8 < (int)0)) {
												pb8 = -(pb8);
											}
											int pc8 = (k8 - c17);
											if ((pc8 < (int)0)) {
												pc8 = -(pc8);
											}
											int cg3;
											bool cg4;
											if ((pa8 <= pb8)) {
												cg4 = (pa8 <= pc8);
											}
											else {
												cg4 = false;
											}
											if (cg4) {
												cg3 = cg;
											}
											else {
												if ((pb8 <= pc8)) {
													cg3 = b13;
												}
												else {
													cg3 = c17;
												}
											}
											::Array< unsigned char > data43 = data->b;
											cg = ((int)(cg3 + data43->__get((r + (int)1))) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cg;
											}
											int b14;
											if ((y1 == (int)0)) {
												b14 = (int)0;
											}
											else {
												::Array< unsigned char > bgra39 = bgra->b;
												b14 = bgra39->__get((w - stride9));
											}
											int c19;
											bool c20;
											if ((x19 != (int)0)) {
												c20 = (y1 == (int)0);
											}
											else {
												c20 = true;
											}
											if (c20) {
												c19 = (int)0;
											}
											else {
												::Array< unsigned char > bgra40 = bgra->b;
												c19 = bgra40->__get(((w - stride9) - (int)4));
											}
											int k9 = ((cr + b14) - c19);
											int pa9 = (k9 - cr);
											if ((pa9 < (int)0)) {
												pa9 = -(pa9);
											}
											int pb9 = (k9 - b14);
											if ((pb9 < (int)0)) {
												pb9 = -(pb9);
											}
											int pc9 = (k9 - c19);
											if ((pc9 < (int)0)) {
												pc9 = -(pc9);
											}
											int cr3;
											bool cr4;
											if ((pa9 <= pb9)) {
												cr4 = (pa9 <= pc9);
											}
											else {
												cr4 = false;
											}
											if (cr4) {
												cr3 = cr;
											}
											else {
												if ((pb9 <= pc9)) {
													cr3 = b14;
												}
												else {
													cr3 = c19;
												}
											}
											cr = ((int)(cr3 + data->b->__get(r)) & (int)(int)255);
											{
												w = (w + (int)1);
												bgra->b[(w - (int)1)] = cr;
											}
											{
												w = (w + (int)1);
												int _hx_tmp17;
												bool _hx_tmp18;
												bool _hx_tmp19;
												if ((cr == alphaRed)) {
													_hx_tmp19 = (cg == alphaGreen);
												}
												else {
													_hx_tmp19 = false;
												}
												if (_hx_tmp19) {
													_hx_tmp18 = (cb == alphaBlue);
												}
												else {
													_hx_tmp18 = false;
												}
												if (_hx_tmp18) {
													_hx_tmp17 = (int)0;
												}
												else {
													_hx_tmp17 = (int)255;
												}
												bgra->b[(w - (int)1)] = _hx_tmp17;
											}
											r = (r + (int)3);
										}
									}
								}
								break;
								default:{
									HX_STACK_DO_THROW((HX_("Invalid filter ",1f,17,bf,04) + f1));
								}
							}
							w = (w + lineDelta);
						}
					}
				}
			}
			break;
			case (int)2: {
				 ::haxe::io::Bytes pal = ::format::png::Tools_obj::getPalette(d);
				if (hx::IsNull( pal )) {
					HX_STACK_DO_THROW(HX_("PNG Palette is missing",0c,e8,57,88));
				}
				 ::haxe::io::Bytes alpha2 = null();
				{
					 ::_List::ListNode _g_head3 = d->h;
					while(hx::IsNotNull( _g_head3 )){
						 ::format::png::Chunk val3 = _g_head3->item;
						_g_head3 = _g_head3->next;
						 ::format::png::Chunk t2 = val3;
						if ((_hx_getEnumValueIndex(t2) == (int)4)) {
							if ((t2->_hx_getString(0) == HX_("tRNS",23,3d,eb,4c))) {
								 ::haxe::io::Bytes data44 = t2->_hx_getObject(1).StaticCast<  ::haxe::io::Bytes >();
								alpha2 = data44;
								goto _hx_goto_45;
							}
						}
					}
					_hx_goto_45:;
				}
				bool _hx_tmp20;
				if (hx::IsNotNull( alpha2 )) {
					int alpha3 = alpha2->length;
					_hx_tmp20 = (alpha3 < ((int)(int)1 << (int)( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) )));
				}
				else {
					_hx_tmp20 = false;
				}
				if (_hx_tmp20) {
					 ::haxe::io::Bytes alpha21 = ::haxe::io::Bytes_obj::alloc(((int)(int)1 << (int)( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) )));
					alpha21->blit((int)0,alpha2,(int)0,alpha2->length);
					int alpha4 = alpha2->length;
					alpha21->fill(alpha4,(alpha21->length - alpha2->length),(int)255);
					alpha2 = alpha21;
				}
				int width2 = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
				int stride10 = (::Math_obj::ceil(((Float)(width2 * ( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) )) / (Float)(int)8)) + (int)1);
				int data45 = data->length;
				if ((data45 < (( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) ) * stride10))) {
					HX_STACK_DO_THROW(HX_("Not enough data",ed,1b,e9,b2));
				}
				int rline = ((int)(( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) ) * ( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) )) >> (int)(int)3);
				{
					int _g15 = (int)0;
					int _g7 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
					while((_g15 < _g7)){
						_g15 = (_g15 + (int)1);
						int y2 = (_g15 - (int)1);
						r = (r + (int)1);
						int f2 = data->b->__get((r - (int)1));
						if ((f2 == (int)0)) {
							r = (r + rline);
							continue;
						}
						switch((int)(f2)){
							case (int)1: {
								int c21 = (int)0;
								{
									int _g321 = (int)0;
									int _g221 = width2;
									while((_g321 < _g221)){
										_g321 = (_g321 + (int)1);
										int x20 = (_g321 - (int)1);
										int v7 = data->b->__get(r);
										c21 = (c21 + v7);
										{
											r = (r + (int)1);
											::Array< unsigned char > data46 = data->b;
											data46[(r - (int)1)] = ((int)c21 & (int)(int)255);
										}
									}
								}
							}
							break;
							case (int)2: {
								int stride11;
								if ((y2 == (int)0)) {
									stride11 = (int)0;
								}
								else {
									stride11 = (rline + (int)1);
								}
								{
									int _g322 = (int)0;
									int _g222 = width2;
									while((_g322 < _g222)){
										_g322 = (_g322 + (int)1);
										int x21 = (_g322 - (int)1);
										int v8 = data->b->__get(r);
										{
											::Array< unsigned char > data47 = data->b;
											data->b[r] = (v8 + data47->__get((r - stride11)));
										}
										r = (r + (int)1);
									}
								}
							}
							break;
							case (int)3: {
								int c22 = (int)0;
								int stride12;
								if ((y2 == (int)0)) {
									stride12 = (int)0;
								}
								else {
									stride12 = (rline + (int)1);
								}
								{
									int _g323 = (int)0;
									int _g223 = width2;
									while((_g323 < _g223)){
										_g323 = (_g323 + (int)1);
										int x22 = (_g323 - (int)1);
										int v9 = data->b->__get(r);
										::Array< unsigned char > data48 = data->b;
										c22 = ((int)(v9 + ((int)(c22 + data48->__get((r - stride12))) >> (int)(int)1)) & (int)(int)255);
										{
											r = (r + (int)1);
											data->b[(r - (int)1)] = c22;
										}
									}
								}
							}
							break;
							case (int)4: {
								int stride13 = (rline + (int)1);
								int c23 = (int)0;
								{
									int _g324 = (int)0;
									int _g224 = width2;
									while((_g324 < _g224)){
										_g324 = (_g324 + (int)1);
										int x23 = (_g324 - (int)1);
										int v10 = data->b->__get(r);
										int b15;
										if ((y2 == (int)0)) {
											b15 = (int)0;
										}
										else {
											::Array< unsigned char > data49 = data->b;
											b15 = data49->__get((r - stride13));
										}
										int c24;
										bool c25;
										if ((x23 != (int)0)) {
											c25 = (y2 == (int)0);
										}
										else {
											c25 = true;
										}
										if (c25) {
											c24 = (int)0;
										}
										else {
											::Array< unsigned char > data50 = data->b;
											c24 = data50->__get(((r - stride13) - (int)1));
										}
										int k10 = ((c23 + b15) - c24);
										int pa10 = (k10 - c23);
										if ((pa10 < (int)0)) {
											pa10 = -(pa10);
										}
										int pb10 = (k10 - b15);
										if ((pb10 < (int)0)) {
											pb10 = -(pb10);
										}
										int pc10 = (k10 - c24);
										if ((pc10 < (int)0)) {
											pc10 = -(pc10);
										}
										int c26;
										bool c27;
										if ((pa10 <= pb10)) {
											c27 = (pa10 <= pc10);
										}
										else {
											c27 = false;
										}
										if (c27) {
											c26 = c23;
										}
										else {
											if ((pb10 <= pc10)) {
												c26 = b15;
											}
											else {
												c26 = c24;
											}
										}
										c23 = ((int)(c26 + v10) & (int)(int)255);
										{
											r = (r + (int)1);
											data->b[(r - (int)1)] = c23;
										}
									}
								}
							}
							break;
							default:{
								HX_STACK_DO_THROW((HX_("Invalid filter ",1f,17,bf,04) + f2));
							}
						}
					}
				}
				int r1 = (int)0;
				if ((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) == (int)8)) {
					int _g16 = (int)0;
					int _g8 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
					while((_g16 < _g8)){
						_g16 = (_g16 + (int)1);
						int y3 = (_g16 - (int)1);
						r1 = (r1 + (int)1);
						{
							int _g325 = (int)0;
							int _g225 = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
							while((_g325 < _g225)){
								_g325 = (_g325 + (int)1);
								int x24 = (_g325 - (int)1);
								r1 = (r1 + (int)1);
								int c28 = data->b->__get((r1 - (int)1));
								{
									w = (w + (int)1);
									::Array< unsigned char > pal1 = pal->b;
									bgra->b[(w - (int)1)] = pal1->__get(((c28 * (int)3) + (int)2));
								}
								{
									w = (w + (int)1);
									::Array< unsigned char > pal2 = pal->b;
									bgra->b[(w - (int)1)] = pal2->__get(((c28 * (int)3) + (int)1));
								}
								{
									w = (w + (int)1);
									::Array< unsigned char > pal3 = pal->b;
									bgra->b[(w - (int)1)] = pal3->__get((c28 * (int)3));
								}
								{
									w = (w + (int)1);
									int v11;
									if (hx::IsNotNull( alpha2 )) {
										v11 = alpha2->b->__get(c28);
									}
									else {
										v11 = (int)255;
									}
									bgra->b[(w - (int)1)] = v11;
								}
							}
						}
						w = (w + lineDelta);
					}
				}
				else {
					if ((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) < (int)8)) {
						int req = ( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) );
						int mask = (((int)(int)1 << (int)req) - (int)1);
						{
							int _g17 = (int)0;
							int _g9 = ( (int)(h->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic)) );
							while((_g17 < _g9)){
								_g17 = (_g17 + (int)1);
								int y4 = (_g17 - (int)1);
								r1 = (r1 + (int)1);
								int bits = (int)0;
								int nbits = (int)0;
								 ::Dynamic v12;
								{
									int _g326 = (int)0;
									int _g226 = ( (int)(h->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic)) );
									while((_g326 < _g226)){
										_g326 = (_g326 + (int)1);
										int x25 = (_g326 - (int)1);
										if ((nbits < req)) {
											r1 = (r1 + (int)1);
											bits = ((int)((int)bits << (int)(int)8) | (int)data->b->__get((r1 - (int)1)));
											nbits = (nbits + (int)8);
										}
										int c29 = ((int)hx::UShr(bits,(nbits - req)) & (int)mask);
										nbits = (nbits - req);
										{
											w = (w + (int)1);
											::Array< unsigned char > pal4 = pal->b;
											bgra->b[(w - (int)1)] = pal4->__get(((c29 * (int)3) + (int)2));
										}
										{
											w = (w + (int)1);
											::Array< unsigned char > pal5 = pal->b;
											bgra->b[(w - (int)1)] = pal5->__get(((c29 * (int)3) + (int)1));
										}
										{
											w = (w + (int)1);
											::Array< unsigned char > pal6 = pal->b;
											bgra->b[(w - (int)1)] = pal6->__get((c29 * (int)3));
										}
										{
											w = (w + (int)1);
											int v13;
											if (hx::IsNotNull( alpha2 )) {
												v13 = alpha2->b->__get(c29);
											}
											else {
												v13 = (int)255;
											}
											bgra->b[(w - (int)1)] = v13;
										}
									}
								}
								w = (w + lineDelta);
							}
						}
					}
					else {
						HX_STACK_DO_THROW((( (int)(h->__Field(HX_("colbits",46,9b,c7,e6),hx::paccDynamic)) ) + HX_(" indexed bits per pixel not supported",99,37,8f,c1)));
					}
				}
			}
			break;
		}
	}
	return bgra;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Tools_obj,extract32,return )

 ::List Tools_obj::buildGrey(int width,int height, ::haxe::io::Bytes data, ::Dynamic __o_level){
 ::Dynamic level = __o_level.Default(9);
            	HX_GC_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_652_buildGrey)
HXLINE( 653)		 ::haxe::io::Bytes rgb = ::haxe::io::Bytes_obj::alloc(((width * height) + height));
HXLINE( 655)		int w = (int)0;
HXDLIN( 655)		int r = (int)0;
HXLINE( 656)		{
HXLINE( 656)			int _g1 = (int)0;
HXDLIN( 656)			int _g = height;
HXDLIN( 656)			while((_g1 < _g)){
HXLINE( 656)				_g1 = (_g1 + (int)1);
HXDLIN( 656)				int y = (_g1 - (int)1);
HXLINE( 657)				{
HXLINE( 657)					w = (w + (int)1);
HXDLIN( 657)					rgb->b[(w - (int)1)] = (int)0;
            				}
HXLINE( 658)				{
HXLINE( 658)					int _g3 = (int)0;
HXDLIN( 658)					int _g2 = width;
HXDLIN( 658)					while((_g3 < _g2)){
HXLINE( 658)						_g3 = (_g3 + (int)1);
HXDLIN( 658)						int x = (_g3 - (int)1);
HXLINE( 659)						{
HXLINE( 659)							w = (w + (int)1);
HXDLIN( 659)							r = (r + (int)1);
HXDLIN( 659)							rgb->b[(w - (int)1)] = data->b->__get((r - (int)1));
            						}
            					}
            				}
            			}
            		}
HXLINE( 661)		 ::List l =  ::List_obj::__alloc( HX_CTX );
HXLINE( 662)		l->add(::format::png::Chunk_obj::CHeader( ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("width",06,b6,62,ca),width)
            			->setFixed(1,HX_("interlaced",91,cb,78,d9),false)
            			->setFixed(2,HX_("colbits",46,9b,c7,e6),(int)8)
            			->setFixed(3,HX_("height",e7,07,4c,02),height)
            			->setFixed(4,HX_("color",63,71,5c,4a),::format::png::Color_obj::ColGrey(false)))));
HXLINE( 663)		l->add(::format::png::Chunk_obj::CData(::format::tools::Deflate_obj::run(rgb,level)));
HXLINE( 664)		l->add(::format::png::Chunk_obj::CEnd_dyn());
HXLINE( 665)		return l;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Tools_obj,buildGrey,return )

 ::List Tools_obj::buildRGB(int width,int height, ::haxe::io::Bytes data, ::Dynamic __o_level){
 ::Dynamic level = __o_level.Default(9);
            	HX_GC_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_671_buildRGB)
HXLINE( 672)		 ::haxe::io::Bytes rgb = ::haxe::io::Bytes_obj::alloc((((width * height) * (int)3) + height));
HXLINE( 674)		int w = (int)0;
HXDLIN( 674)		int r = (int)0;
HXLINE( 675)		{
HXLINE( 675)			int _g1 = (int)0;
HXDLIN( 675)			int _g = height;
HXDLIN( 675)			while((_g1 < _g)){
HXLINE( 675)				_g1 = (_g1 + (int)1);
HXDLIN( 675)				int y = (_g1 - (int)1);
HXLINE( 676)				{
HXLINE( 676)					w = (w + (int)1);
HXDLIN( 676)					rgb->b[(w - (int)1)] = (int)0;
            				}
HXLINE( 677)				{
HXLINE( 677)					int _g3 = (int)0;
HXDLIN( 677)					int _g2 = width;
HXDLIN( 677)					while((_g3 < _g2)){
HXLINE( 677)						_g3 = (_g3 + (int)1);
HXDLIN( 677)						int x = (_g3 - (int)1);
HXLINE( 678)						{
HXLINE( 678)							w = (w + (int)1);
HXDLIN( 678)							::Array< unsigned char > data1 = data->b;
HXDLIN( 678)							rgb->b[(w - (int)1)] = data1->__get((r + (int)2));
            						}
HXLINE( 679)						{
HXLINE( 679)							w = (w + (int)1);
HXDLIN( 679)							::Array< unsigned char > data2 = data->b;
HXDLIN( 679)							rgb->b[(w - (int)1)] = data2->__get((r + (int)1));
            						}
HXLINE( 680)						{
HXLINE( 680)							w = (w + (int)1);
HXDLIN( 680)							rgb->b[(w - (int)1)] = data->b->__get(r);
            						}
HXLINE( 681)						r = (r + (int)3);
            					}
            				}
            			}
            		}
HXLINE( 684)		 ::List l =  ::List_obj::__alloc( HX_CTX );
HXLINE( 685)		l->add(::format::png::Chunk_obj::CHeader( ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("width",06,b6,62,ca),width)
            			->setFixed(1,HX_("interlaced",91,cb,78,d9),false)
            			->setFixed(2,HX_("colbits",46,9b,c7,e6),(int)8)
            			->setFixed(3,HX_("height",e7,07,4c,02),height)
            			->setFixed(4,HX_("color",63,71,5c,4a),::format::png::Color_obj::ColTrue(false)))));
HXLINE( 686)		l->add(::format::png::Chunk_obj::CData(::format::tools::Deflate_obj::run(rgb,level)));
HXLINE( 687)		l->add(::format::png::Chunk_obj::CEnd_dyn());
HXLINE( 688)		return l;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Tools_obj,buildRGB,return )

 ::List Tools_obj::build32ARGB(int width,int height, ::haxe::io::Bytes data, ::Dynamic __o_level){
 ::Dynamic level = __o_level.Default(9);
            	HX_GC_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_694_build32ARGB)
HXLINE( 695)		 ::haxe::io::Bytes rgba = ::haxe::io::Bytes_obj::alloc((((width * height) * (int)4) + height));
HXLINE( 697)		int w = (int)0;
HXDLIN( 697)		int r = (int)0;
HXLINE( 698)		{
HXLINE( 698)			int _g1 = (int)0;
HXDLIN( 698)			int _g = height;
HXDLIN( 698)			while((_g1 < _g)){
HXLINE( 698)				_g1 = (_g1 + (int)1);
HXDLIN( 698)				int y = (_g1 - (int)1);
HXLINE( 699)				{
HXLINE( 699)					w = (w + (int)1);
HXDLIN( 699)					rgba->b[(w - (int)1)] = (int)0;
            				}
HXLINE( 700)				{
HXLINE( 700)					int _g3 = (int)0;
HXDLIN( 700)					int _g2 = width;
HXDLIN( 700)					while((_g3 < _g2)){
HXLINE( 700)						_g3 = (_g3 + (int)1);
HXDLIN( 700)						int x = (_g3 - (int)1);
HXLINE( 701)						{
HXLINE( 701)							w = (w + (int)1);
HXDLIN( 701)							::Array< unsigned char > data1 = data->b;
HXDLIN( 701)							rgba->b[(w - (int)1)] = data1->__get((r + (int)1));
            						}
HXLINE( 702)						{
HXLINE( 702)							w = (w + (int)1);
HXDLIN( 702)							::Array< unsigned char > data2 = data->b;
HXDLIN( 702)							rgba->b[(w - (int)1)] = data2->__get((r + (int)2));
            						}
HXLINE( 703)						{
HXLINE( 703)							w = (w + (int)1);
HXDLIN( 703)							::Array< unsigned char > data3 = data->b;
HXDLIN( 703)							rgba->b[(w - (int)1)] = data3->__get((r + (int)3));
            						}
HXLINE( 704)						{
HXLINE( 704)							w = (w + (int)1);
HXDLIN( 704)							rgba->b[(w - (int)1)] = data->b->__get(r);
            						}
HXLINE( 705)						r = (r + (int)4);
            					}
            				}
            			}
            		}
HXLINE( 708)		 ::List l =  ::List_obj::__alloc( HX_CTX );
HXLINE( 709)		l->add(::format::png::Chunk_obj::CHeader( ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("width",06,b6,62,ca),width)
            			->setFixed(1,HX_("interlaced",91,cb,78,d9),false)
            			->setFixed(2,HX_("colbits",46,9b,c7,e6),(int)8)
            			->setFixed(3,HX_("height",e7,07,4c,02),height)
            			->setFixed(4,HX_("color",63,71,5c,4a),::format::png::Color_obj::ColTrue(true)))));
HXLINE( 710)		l->add(::format::png::Chunk_obj::CData(::format::tools::Deflate_obj::run(rgba,level)));
HXLINE( 711)		l->add(::format::png::Chunk_obj::CEnd_dyn());
HXLINE( 712)		return l;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Tools_obj,build32ARGB,return )

 ::List Tools_obj::build32BGRA(int width,int height, ::haxe::io::Bytes data, ::Dynamic __o_level){
 ::Dynamic level = __o_level.Default(9);
            	HX_GC_STACKFRAME(&_hx_pos_7ba0aa4bcda37a20_718_build32BGRA)
HXLINE( 719)		 ::haxe::io::Bytes rgba = ::haxe::io::Bytes_obj::alloc((((width * height) * (int)4) + height));
HXLINE( 721)		int w = (int)0;
HXDLIN( 721)		int r = (int)0;
HXLINE( 722)		{
HXLINE( 722)			int _g1 = (int)0;
HXDLIN( 722)			int _g = height;
HXDLIN( 722)			while((_g1 < _g)){
HXLINE( 722)				_g1 = (_g1 + (int)1);
HXDLIN( 722)				int y = (_g1 - (int)1);
HXLINE( 723)				{
HXLINE( 723)					w = (w + (int)1);
HXDLIN( 723)					rgba->b[(w - (int)1)] = (int)0;
            				}
HXLINE( 724)				{
HXLINE( 724)					int _g3 = (int)0;
HXDLIN( 724)					int _g2 = width;
HXDLIN( 724)					while((_g3 < _g2)){
HXLINE( 724)						_g3 = (_g3 + (int)1);
HXDLIN( 724)						int x = (_g3 - (int)1);
HXLINE( 725)						{
HXLINE( 725)							w = (w + (int)1);
HXDLIN( 725)							::Array< unsigned char > data1 = data->b;
HXDLIN( 725)							rgba->b[(w - (int)1)] = data1->__get((r + (int)2));
            						}
HXLINE( 726)						{
HXLINE( 726)							w = (w + (int)1);
HXDLIN( 726)							::Array< unsigned char > data2 = data->b;
HXDLIN( 726)							rgba->b[(w - (int)1)] = data2->__get((r + (int)1));
            						}
HXLINE( 727)						{
HXLINE( 727)							w = (w + (int)1);
HXDLIN( 727)							rgba->b[(w - (int)1)] = data->b->__get(r);
            						}
HXLINE( 728)						{
HXLINE( 728)							w = (w + (int)1);
HXDLIN( 728)							::Array< unsigned char > data3 = data->b;
HXDLIN( 728)							rgba->b[(w - (int)1)] = data3->__get((r + (int)3));
            						}
HXLINE( 729)						r = (r + (int)4);
            					}
            				}
            			}
            		}
HXLINE( 732)		 ::List l =  ::List_obj::__alloc( HX_CTX );
HXLINE( 733)		l->add(::format::png::Chunk_obj::CHeader( ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("width",06,b6,62,ca),width)
            			->setFixed(1,HX_("interlaced",91,cb,78,d9),false)
            			->setFixed(2,HX_("colbits",46,9b,c7,e6),(int)8)
            			->setFixed(3,HX_("height",e7,07,4c,02),height)
            			->setFixed(4,HX_("color",63,71,5c,4a),::format::png::Color_obj::ColTrue(true)))));
HXLINE( 734)		l->add(::format::png::Chunk_obj::CData(::format::tools::Deflate_obj::run(rgba,level)));
HXLINE( 735)		l->add(::format::png::Chunk_obj::CEnd_dyn());
HXLINE( 736)		return l;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Tools_obj,build32BGRA,return )


Tools_obj::Tools_obj()
{
}

bool Tools_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"filter") ) { outValue = filter_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"buildRGB") ) { outValue = buildRGB_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"getHeader") ) { outValue = getHeader_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"extract32") ) { outValue = extract32_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"buildGrey") ) { outValue = buildGrey_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getPalette") ) { outValue = getPalette_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"extractGrey") ) { outValue = extractGrey_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"build32ARGB") ) { outValue = build32ARGB_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"build32BGRA") ) { outValue = build32BGRA_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"reverseBytes") ) { outValue = reverseBytes_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Tools_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *Tools_obj_sStaticStorageInfo = 0;
#endif

static void Tools_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Tools_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Tools_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Tools_obj::__mClass,"__mClass");
};

#endif

hx::Class Tools_obj::__mClass;

static ::String Tools_obj_sStaticFields[] = {
	HX_HCSTRING("getHeader","\xc3","\x92","\x56","\x79"),
	HX_HCSTRING("getPalette","\x85","\x18","\xc5","\xbb"),
	HX_HCSTRING("filter","\xb8","\x1f","\x35","\x85"),
	HX_HCSTRING("reverseBytes","\xe9","\xe3","\xfc","\xd3"),
	HX_HCSTRING("extractGrey","\x40","\xe9","\x39","\x59"),
	HX_HCSTRING("extract32","\x20","\x74","\xf3","\x90"),
	HX_HCSTRING("buildGrey","\xad","\x09","\xa8","\xe4"),
	HX_HCSTRING("buildRGB","\x7f","\x4c","\xb6","\x53"),
	HX_HCSTRING("build32ARGB","\x19","\x2f","\x4e","\x75"),
	HX_HCSTRING("build32BGRA","\x81","\x16","\xef","\x75"),
	::String(null())
};

void Tools_obj::__register()
{
	hx::Object *dummy = new Tools_obj;
	Tools_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("format.png.Tools","\x7f","\x40","\x56","\xda");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Tools_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Tools_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Tools_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Tools_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Tools_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Tools_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Tools_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace format
} // end namespace png
